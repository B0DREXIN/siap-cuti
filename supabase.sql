-- 1. Create profiles table
create table public.profiles (
  id uuid not null references auth.users on delete cascade,
  name text,
  id_pjlp text unique,
  phone text,
  email text,
  avatar_url text,
  role text default 'anggota',
  updated_at timestamp with time zone,
  primary key (id)
);

alter table public.profiles enable row level security;

-- 2. Create leave_requests table
create table public.leave_requests (
    id bigint generated by default as identity primary key,
    user_id uuid not null references public.profiles(id) on delete cascade,
    title text not null,
    reason text,
    start_date date not null,
    end_date date not null,
    duration integer not null,
    status text not null default 'Menunggu',
    attachment_url text,
    is_read boolean default false,
    created_at timestamp with time zone default now() not null,
    updated_at timestamp with time zone default now() not null
);

alter table public.leave_requests enable row level security;

-- 3. Create leave_balances table
create table public.leave_balances (
    id bigint generated by default as identity primary key,
    user_id uuid not null references public.profiles(id) on delete cascade,
    year integer not null,
    total_days integer not null default 12,
    used_days integer not null default 0,
    unique (user_id, year)
);

alter table public.leave_balances enable row level security;

-- 4. Create function to get user role
create or replace function public.get_user_role()
returns text
language sql
security definer
set search_path = public
as $$
  select role from public.profiles where id = auth.uid();
$$;


-- 5. Set up trigger to automatically create a profile when a new user signs up
create or replace function public.handle_new_user()
returns trigger
language plpgsql
security definer
set search_path = public
as $$
begin
  insert into public.profiles (id, name, id_pjlp, phone, email, role)
  values (
    new.id,
    new.raw_user_meta_data ->> 'name',
    new.raw_user_meta_data ->> 'id_pjlp',
    new.raw_user_meta_data ->> 'phone',
    new.email,
    'anggota' -- Default role
  );
  -- Also create their initial leave balance for the current year
  insert into public.leave_balances (user_id, year, total_days, used_days)
  values (new.id, date_part('year', now()), 12, 0);
  return new;
end;
$$;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- 6. Create RPC to update leave balance atomically
create or replace function public.update_leave_balance(p_user_id uuid, p_year integer, p_days_to_add integer)
returns void
language plpgsql
as $$
begin
  -- This ensures a balance record exists before trying to update it.
  insert into public.leave_balances(user_id, year, total_days, used_days)
  values (p_user_id, p_year, 12, 0)
  on conflict (user_id, year) do nothing;

  update public.leave_balances
  set used_days = used_days + p_days_to_add
  where user_id = p_user_id and year = p_year;
end;
$$;


-- POLICIES --

-- 1. Policies for profiles table
create policy "Users can view their own profile" on public.profiles for select using (auth.uid() = id);
create policy "Users can update their own profile" on public.profiles for update using (auth.uid() = id) with check (auth.uid() = id);
create policy "Admins can view all profiles" on public.profiles for select using (public.get_user_role() = 'admin');
create policy "Admins can update any profile" on public.profiles for update using (public.get_user_role() = 'admin') with check (public.get_user_role() = 'admin');
create policy "Admins can delete any profile" on public.profiles for delete using (public.get_user_role() = 'admin');
-- Note: A policy for insert is not needed for profiles as it's handled by the handle_new_user trigger.

-- 2. Policies for leave_requests table
create policy "Users can view their own leave requests" on public.leave_requests for select using (auth.uid() = user_id);
create policy "Users can insert their own leave requests" on public.leave_requests for insert with check (auth.uid() = user_id);
create policy "Users can't update or delete their requests" on public.leave_requests for update using (false);
create policy "Users can't delete their requests" on public.leave_requests for delete using (false);
create policy "Admins can view all leave requests" on public.leave_requests for select using (public.get_user_role() = 'admin');
create policy "Admins can update any leave request" on public.leave_requests for update using (public.get_user_role() = 'admin') with check (public.get_user_role() = 'admin');

-- 3. Policies for leave_balances table
create policy "Users can view their own leave balance" on public.leave_balances for select using (auth.uid() = user_id);
create policy "Admins can view all leave balances" on public.leave_balances for select using (public.get_user_role() = 'admin');
-- Note: Balances are updated via RPC or triggers, so direct update/insert policies for users are restrictive.
create policy "Admins can manage balances" on public.leave_balances for all using (public.get_user_role() = 'admin');

-- STORAGE POLICIES (If you use attachments)
-- create policy "Give users access to their own folder"
-- on storage.objects for select
-- using ( bucket_id = 'attachments' and auth.uid()::text = (storage.foldername(name))[1] );

-- create policy "allow users to upload to their folder"
-- on storage.objects for insert
-- with check ( bucket_id = 'attachments' and auth.uid()::text = (storage.foldername(name))[1] );
